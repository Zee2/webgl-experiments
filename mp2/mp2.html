<!DOCTYPE HTML> 
<html lang="en"> 
<head>
<title>MP2</title>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="mp2.css">
<link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&display=swap" rel="stylesheet">
</head>
 
<script id="shader-vs" type="x-shader/x-vertex">

  precision mediump float;

  attribute vec4 aVertexPosition;
  attribute vec3 aVertexNormal;
  
  uniform float time;

  varying vec3 vNormal;
  varying vec4 vWorldPos;
  varying vec3 vEyePos;

  uniform mat4 u_modelview;
  uniform mat4 u_projection;
  uniform mat3 u_normalMatrix;
  
  void main(void) {
      vNormal = aVertexNormal;
      gl_Position = u_projection * u_modelview * aVertexPosition;
      
      vWorldPos = aVertexPosition;

      vec4 vEyePos4 = (u_modelview * vec4(aVertexPosition.xyz, 1.0));
      vEyePos = vEyePos4.xyz / vEyePos4.w;
  }
  </script>
    
  <script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;

  uniform mat4 u_modelview;
  uniform mat3 u_normalMatrix;

  uniform float time;
  uniform float u_shininess;
  uniform float u_useBlinnPhong;

  varying vec4 vColor;
  varying vec4 vWorldPos;
  varying vec3 vEyePos;
  varying vec3 vNormal;

  #define SNOW vec4(0.9, 0.9, 0.9, 1)
  #define ROCK vec4(0.3, 0.3, 0.3, 1)
  #define GRASS vec4(0.1, 0.3, 0.05, 1)
  #define WATER vec4(0, 0, 0.4, 1)
  #define MAX 3.0

  // These could be uniforms, but I don't really feel
  // like exposing all of these to the user
  // (that's a lot of knobs and buttons)
  #define NUM_LIGHTS 2.
  #define AMBIENT_STRENGTH 0.15
  #define DIFFUSE_STRENGTH 0.9


  void main(void) {

    // We declare all the temp variables for the lighting formula here
    // so that we can seamlessly switch out the lighting algorithm
    // without dealing with a mess of variable declarations
    vec4 vLightPos4;
    vec3 vectorToLightSource;
    vec3 normalEye;
    float diffuseLightWeightning;
    vec3 reflectionVector;
    vec3 viewVectorEye;
    vec3 halfwayVector;
    float rdotv;
    float ndoth;
    float diffuse;
    float specWeighting;
    vec4 phongColor;
    vec3 vLightPos;

    vec4 baseColor;

    // First, calculate base color

    if(vWorldPos.y / MAX > 0.7){
      baseColor = mix(ROCK, SNOW, smoothstep(0.7, 0.74, vWorldPos.y / MAX));
    } else if(vWorldPos.y / MAX > 0.5){
      baseColor = mix(GRASS, ROCK, smoothstep(0.5, 0.7, vWorldPos.y / MAX));
    } else if(vWorldPos.y / MAX > 0.2){
      baseColor = mix(WATER, GRASS, smoothstep(0.2, 0.22, vWorldPos.y / MAX));
    } else {
      baseColor = WATER;
    }

    // Ambient light calculation
    // We do it first, as it's common to both Phong and Blinn-Phong
    gl_FragColor = AMBIENT_STRENGTH * baseColor;

    // Transform the normal (n) to eye coordinates
    normalEye = normalize(u_normalMatrix * vNormal);
    
    // The camera in eye coordinates is located in the origin and is pointing
    // along the negative z-axis. Calculate viewVector (v) 
    // in eye coordinates as:
    // (0.0, 0.0, 0.0) - vertexPositionEye3
    viewVectorEye = -normalize(vEyePos);

    for(float i = 0.; i < NUM_LIGHTS; i++){

      vLightPos4 = (u_modelview * vec4(5.0*cos(time * 0.001 + ((2.*3.141)/NUM_LIGHTS) * i) + 7., 3.0, 5.0*sin(time * 0.001 + ((2.*3.141)/NUM_LIGHTS) * i) + 7., 1.0));
      //vec4 vLightPos4 = (u_modelview * vec4(4.0, 2.0, 4.0, 1.0));
      vLightPos = vLightPos4.xyz / vLightPos4.w;



      // Calculate the vector (l) to the light source
      vectorToLightSource = normalize(vLightPos - vEyePos);
      
      // Calculate n dot l for diffuse lighting
      diffuseLightWeightning = max(dot(normalEye, 
                                      vectorToLightSource), 0.0);
                                        
      // Calculate the reflection vector (r) that is needed for specular light
      reflectionVector = normalize(reflect(-vectorToLightSource, 
                                              normalEye));

      // Calculate the halfway vector (h)
      halfwayVector = (vectorToLightSource + viewVectorEye) / length(vectorToLightSource + viewVectorEye);

      // RdotV, for phong model only
      rdotv = max(dot(reflectionVector, viewVectorEye), 0.0);

      // NdotH, for blinn-phong
      ndoth = max(dot(normalEye, halfwayVector), 0.0);

      diffuse = max(dot(normalEye, vectorToLightSource), 0.0);

      // Depending on the currently selected shading model (Phong or Blinn-Phong)
      // we change the dot product we perform. (RdotV or NdotH)
      if(u_useBlinnPhong > 0.5){
        specWeighting = pow(rdotv, u_shininess);
      } else {
        specWeighting = pow(ndoth, u_shininess);
      }
      
      
      // Perform the rest of the shading calculation.
      // We don't do the ambient here, we already did it above (before the shading calculation)
      gl_FragColor += vec4(((vec3(DIFFUSE_STRENGTH)*baseColor.xyz) * diffuse
                        + (vec3(0.4)*vec3(1.0)) * specWeighting),1.0);
      
      
    }
    
  }
  </script>

<body style = "font-family: roboto; color: white; background-color: #131313" onload="startup();">
  <div class = "header" >
    <h1 style = "font-family: roboto mono; ">
      CS418 MP2
    </h1>
    <p style = "font-family: roboto mono">
      Finn Sinclair - 2019
    </p>
    
    <div class="uiContainer">
      <div id="ui">
        <div class="slidecontainer">
          <input type="range" min="10" max="500" value="100" class="slider" id="shininess"> Shininess
        </div>
        <div class="radiobutton">
          <input type="radio" class="radiobutton" value="yes" name="use_blinnphong" checked> Use Blinn-Phong
          <input type="radio" class="radiobutton" value="no" name="use_blinnphong"> Use Phong
        </div>
        <div class="sphereButton">
          <input type="button" name="toggle_sphere" id="toggle_sphere"value="Toggle sphere material visualization"> 
        </div>
        
        Use the <b><i>mouse</i></b> or <b><i>touchscreen</i></b> to spin the model and dolly-zoom forward and backwards! <br>
        The scene has two rotating lights, that rotate automatically in a wide circle around the origin.
      </div>
      
    </div>
  </div>
  <canvas class="canvas" id="myGLCanvas" width="1000" height = "600"></canvas>
  
  
</body>

<script src="scripts/gl-matrix.js"></script>   
<script src="scripts/webgl-utils.js"></script>
<script src="scripts/mouseControls.js"></script>
<script src="scripts/simpleModeling.js"></script>
<script src="scripts/helpers.js"></script>
<script src="scripts/terrain_demo.js"></script>  
<script src="scripts/mp2.js"></script>   

</html>
